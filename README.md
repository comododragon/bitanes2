# Bitanes2

## Author

* André Bannwart Perina
* Betweenness algorithm developed by Ulrik Brandes
	* Brandes, Ulrik. "A faster algorithm for betweenness centrality." Journal of mathematical sociology 25.2 (2001): 163-177.

## Introduction

This is a simple sequential implementation of the betweenness centrality algorithm developed by Brandes. It was developed as a coursework for the "Parallel Programming Introduction" module offered at the University of São Paulo - Brazil.

## Licence

GNU General Public Licence (see LICENSE file).

## Prerequisites

* Usual GNU C compiler and runtime:
	* GNU C Compiler (gcc, tested with version 7.1.1 20170630);
	* GNU C Library (glibc, tested with version 2.25).

## How to Download and Execute

1. Clone repo, access folder and download submodules:

```
git clone https://github.com/comododragon/bitanes2.git
cd bitanes2
git submodule update --init --recursive
```

2. Compile using ```make``` (see ***Description of Compiling Options*** for compiling settings):

```
make bin/bitanes2
```

3. Execute, passing as argument the input graph, e.g.:

```
./bin/bitanes2 data/small/er_20_4_03.net
```

4. The results will be available in the same folder as the input file, with the extension ```.btw``` (e.g. ```data/small/er_20_4_03.btw```)

## Description of Compiling Options

The Makefile provided with this project has some compilation options:

```make bin/bitanes2 DEBUG=yes GPROF=yes GCOV=yes OPTLEVEL=x```

where:

* ```DEBUG=yes```: Activate debug flag ```-g```;
* ```GPROF=yes```: Activate flags for profiling with ```gprof```;
* ```GCOV=yes```: Activate flags for coverage test with ```gcov```;
* ```OPTLEVEL=x```: Choose optimisation level of the algorithm (not to be confused with ```-O2``` or ```-O3```, see ***Description of Optimisation Levels***):
	* ```OPTLEVEL=0```: Adjacency matrix is used; Linked queues and FIFOs have no tail pointer;
	* ```OPTLEVEL=1```: Adjacency matrix is used;
	* ```OPTLEVEL=2```: Adjacency list is used; A list of neighbour nodes is retrieved instead of an adjacency line for all nodes.

***If one wants to change the options after compiling once, run:*** ```make clean``` ***first.***

## Description of Optimisation Levels

Throughout the development, several optimisations were made to improve performance. Three levels were maintained for educational purposes:

* ***Level 0***:
	* Adjacency matrix is used, which is not recommended for sparse graphs. In line 12 from the original algorithm, we have ```foreach neighbor w of v do```, i.e., the whole line ```v``` of the adjacency matrix will be tested to see if each element ```w``` is a neighbour or not:
		```
		for(w = 0; w < n; w++) {
			if(graph_getEdge(graph, v, w)) {
				/* Hit */
			}
			/* Else: miss */
		}
		```
		For sparse graphs, this will lead to several misses (not neighbours), leading also to increased redundancy.
	* Linked queues and FIFOs have no tail pointer. Without tail pointers in linked lists, the whole list must be iterated to access the tail of it (e.g. for queue/FIFO pushback);
* ***Level 1***:
	* Adjacency matrix is used;
	* Linked queues and FIFOs HAVE tail pointer;
* ***Level 2***:
	* Adjacency list is used, which is more suitable for sparse graphs;
	* Since each line ```v``` of the adjacency list contains all neighbouring nodes of ```v```, this may be used to directly map the ```foreach neighbor w of v do``` line, reducing misses of neighbour nodes to zero:
		```
		int *adjacents = graph_getAdjacents(graph, v, &noOfAdjacents);
		for(i = 0; i < noOfAdjacents; i++) {
			w = adjacents[i];

			/* Always hit */
		}
		```
	* Linked queues and FIFOs HAVE tail pointer.

## Performance of each Optimisation Level

The optimisation was driven according to results generated by ```gprof```, where the most time-consuming functions were adapted for performance improvement.

* ***Level 0***:
	* ***GCOV results (using data/big/ba_1000_4_01.net):***
	* ***Execution times:***
		* ***Small graph 1 (20 nodes, 36 edges, filename data/small/ba_20_4_03.net):*** 5 ms
		* ***Small graph 2 (20 nodes, 31 edges, filename data/small/er_20_4_03.net):*** 4 ms
		* ***Large graph 1 (1000 nodes, 1996 edges, filename data/big/ba_1000_4_01.net):*** 3512 ms
		* ***Large graph 2 (10000 nodes, 159744 edges, filename data/big/er_10000_32_01.net):*** --- ms
* ***Level 1***:
	* ***GCOV results (using data/big/ba_1000_4_01.net):***
	* ***Execution times:***
		* ***Small graph 1 (20 nodes, 36 edges, filename data/small/ba_20_4_03.net):*** 5 ms
		* ***Small graph 2 (20 nodes, 31 edges, filename data/small/er_20_4_03.net):*** 3 ms
		* ***Large graph 1 (1000 nodes, 1996 edges, filename data/big/ba_1000_4_01.net):*** 2600 ms
		* ***Large graph 2 (10000 nodes, 159744 edges, filename data/big/er_10000_32_01.net):*** --- ms
* ***Level 2***:
	* ***GCOV results (using data/big/ba_1000_4_01.net):***
	* ***Execution times:***
		* ***Small graph 1 (20 nodes, 36 edges, filename data/small/ba_20_4_03.net):*** 5 ms
		* ***Small graph 2 (20 nodes, 31 edges, filename data/small/er_20_4_03.net):*** 4 ms
		* ***Large graph 1 (1000 nodes, 1996 edges, filename data/big/ba_1000_4_01.net):*** 190 ms
		* ***Large graph 2 (10000 nodes, 159744 edges, filename data/big/er_10000_32_01.net):*** 57010 ms

## File Structure

* ```bin```: folder for executable files;
* ```data```: dataset of graphs;
	* ```big```: large graphs (up to 10000 nodes);
	* ```small```: small graphs (up to 20 nodes);
* ```include```;
	* ```common```;
		* ```common.h```: procedures used for error detection and reporting (e.g. assert);
	* ```graph.h```: header of graph data structure;
	* ```list.h```: header of list/queue/FIFO data structure;
* ```obj```: folder for object files (```.o```);
* ```src```:
	* ```bitanes2.c```: main function source;
	* ```graph.c```: source of graph data structure;
	* ```list.c```: source of list/queue/FIFO data structure;
* ```Makefile```: project makefile.
